#!/bin/sh

# Based on https://github.com/cirala/vifmimg, licensed under GPL-3.0
# All changes are licensed under GPL-3.0
# Authors: cirala, L. Abramovich

# Description
# Convert (if necessary) and generate previews (as thumbnails) for images.
# Thumbnails are cached (in $CACHE_DIR) using file hashes as names.
#
# The first parameter tells what file type is to be converted/displayed
# (supported types: image, gif, video, epub, mobi, pdf, svg, doc, djvu, audio, font, postscript)
# The second one is the file name to be converted/displayed.

######################
# Usage
######################
#
# This script is intended to be used by shotgun, Clifm's built-in previewer,
# to generate and display image previews for several file types.
# Follow these steps to enable it:
#
# 1) (Ueberzug/kitty only) Copy 'clifmrun' somewhere in you $PATH (say
# /usr/local/bin)
#
# 2) Edit shotgun's config file (F7 or "view edit") and add the following lines at
# the top of the file (to make sure they won't be overriden by previous directives):
#
#^application/.*(officedocument|msword|ms-excel|ms-powerpoint|opendocument).*=~/.config/clifm/clifmimg doc;
#^text/rtf$=~/.config/clifm/clifmimg doc;
#^application/epub\+zip$=~/.config/clifm/clifmimg epub;
#^application/x-mobipocket-ebook$=~/.config/clifm/clifmimg mobi;
#.*/pdf$=~/.config/clifm/clifmimg pdf
#^image/vnd.djvu=~/.config/clifm/clifmimg djvu
#^image/svg\+xml$=~/.config/clifm/clifmimg svg;
#^image/gif$=~/.config/clifm/clifmimg gif;
#^image/.*=~/.config/clifm/clifmimg image;
#^video/.*=~/.config/clifm/clifmimg video;
#^audio/.*=~/.config/clifm/clifmimg audio;
#^application/postscript$=~/.config/clifm/clifmimg postscript;
#^font/.*|^application/(font.*|.*opentype)=~/.config/clifm/clifmimg font;
#
# This instructs clifm to use this script to generate previews for the
# specified files.
# In case you don't want image preview for some of these files types, just
# comment out the corresponding line or change its value to your preferred
# previewing application.
#
# 4) (Ueberzug/kitty only): Run clifm via the 'clifmrun' script (which
# takes care of running an instance of ueberzug/kitty and set the appropriate
# values so that it can be used by Clifm via shotgun, which calls this script
# to generate previews).

######################
# Dependencies
######################
#
# ueberzug/kitty terminal (optional)
# md5sum/md5 (generate file hashes)
#
# The following applications are used to generate thumbnails:
#
# ffmpegthumbnailer (Video files)
# gnome-epub-thumbnailer/epub-thumbnailer (ePub files)
# gnome-mobi-thumbnailer (Mobi files)
# pdftoppm (PDF files - provided by the poppler package)
# ddjvu (DjVu files - provided by the djvulibre package)
# ffmpeg (Audio files)
# fontpreview (Font files)
# libreoffice (Office files: odt, docx, xlsx, etc)
# gs (Postscript files - provided by the ghostscript package)
# magick (GIF, SVG files, and sixel images - provided by the imagemagick package)
#
# Note: The exact package names provinding these programs vary depending
# on your OS/distribution, but ususally they have the same name as the program

type="$1"
file="$2"

CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/clifm/previews"
CACHEDIRTAG_FILE="$CACHE_DIR/CACHEDIR.TAG"
CACHEDIRTAG_HEADER="Signature: 8a477f597d28d172789f06886806bc55
# This file is a cache directory tag created by Clifm.
# For information about cache directory tags, see:
#	http://www.brynosaurus.com/cachedir/"

# Use hashes instead of file names for cached files to generate unique file names
hash_file() {
	! [ -d "$CACHE_DIR" ] && mkdir -p "$CACHE_DIR"
	! [ -f "$CACHEDIRTAG_FILE" ] && echo "$CACHEDIRTAG_HEADER" > "$CACHEDIRTAG_FILE"
	if type md5sum > /dev/null 2>&1; then
		PCACHE="$CACHE_DIR/$(md5sum "$1" | cut -d' ' -f1)"
	elif type md5 > /dev/null 2>&1; then
		PCACHE="$CACHE_DIR/$(md5 -q "$1")"
	else
		printf "clifm: No hashing application found.\nEither md5sum or md5 \
is required.\n" >&2
		exit 1
	fi
}

display() {
	[ -z "$1" ] && exit 1

	if [ -n "$FZF_PREVIEW_LINES" ]; then
		C=$((FZF_PREVIEW_COLUMNS - 2))
		L=$FZF_PREVIEW_LINES
	else
		[ -z $COLUMNS ] && COLUMNS="$(tput cols)"
		[ -z $LINES ] && LINES="$(tput lines)"
		C=$COLUMNS
		L=$LINES
	fi

	if [ -z "$CLIFM_FZF_LINE" ]; then
		CLIFM_FZF_LINE=0
		CLIFM_TERM_COLUMNS=$COLUMNS
	fi

## Uncomment any of the following previewing methods (instead of kitty or ueberzug).
# If using any of these methods, there is no need to run via clifmrun; just run clifm as always.
#
# New: since 0.44, fzf added sixel support.
#	chafa -f sixel -s "${C}x$((L - 1))" "$1"; exit 0

#	chafa -f symbols -s "${C}x${L}" "$1"; exit 0
#	pixterm -s 2 -tc "${C}" -tr "${L}" "$1"; exit 0
#	img2txt -H"${L}" -W"${C}" "$1"; exit 0
#	viu -b -h"${L}" -w"${C}" "$1"; exit 0
#	catimg -H"${L}" "$1"; exit 0
#	tiv -h "${L}" -w "${C}" "$1"; exit 0
#	timg -g "${C}x${L}" "$1"; exit 0
#	explosion -w "${C}" -h "${L}" "$1"; exit 0
##

	# CLIFM_TERM_COLUMNS: Number of columns of the current terminal
	# window (value exported by clifm)
	# FZF_PREVIEW_COLUMNS: Number of columns of the fzf preview
	# window (value exported by fzf itself)
	# CLIFM_FZF_LINE: Terminal line of the fzf window (exported by clifm)
	X=$((CLIFM_TERM_COLUMNS - FZF_PREVIEW_COLUMNS))
	Y=$CLIFM_FZF_LINE

	if [ -n "$CLIFM_KITTY_IMG" ]; then
		# CLIFM_KITTY_IMG is the path to a temp file created by clifmrun
		# if running on a kitty terminal
		# This is a pretty dirty hack: let's create an empty temp file
		# (CLIFM_KITTY_IMG) to let clifm know that an image is displayed
		# and should be removed

		touch -- "$CLIFM_KITTY_IMG"
		kitty icat --loop=0 --place "$FZF_PREVIEW_COLUMNS"x"$FZF_PREVIEW_LINES"@"$X"x"$Y" \
		--clear --transfer-mode=stream --stdin=no --align=left -- "$1"
	else
		printf '{"action": "add", "identifier": "clifm-preview", "x": "%s", "y": "%s", "width": "%s", "height": "%s", "scaler" : "contain", "path": "%s"}\n' "$X" "$Y" "$COLUMNS" "$LINES" "$1" > "$CLIFM_FIFO_UEBERZUG"
	fi
}

print_err_msg() {
	case "$2" in
		127) echo "${1}: Command not found";;
		*) echo "${1}: Error generating preview (code: $2)";;
	esac
	return 1
}

gen_epub_preview() {
	gnome-epub-thumbnailer -s 1024 "$1" "$2" >/dev/null 2>&1 && return 0
	print_err_msg "gnome-epub-thumbnailer" "$?"
	epub-thumbnailer "$1" "$2" 1024 >/dev/null 2>&1 && return 0
	print_err_msg "epub-thumbnailer" "$?"
}

gen_mobi_preview() {
	gnome-mobi-thumbnailer -s 1024 "$1" "$2" >/dev/null 2>&1 && return 0
	print_err_msg "gnome-mobi-thumbnailer" "$?"
}

gen_pdf_preview() {
	pdftoppm -jpeg -f 1 -singlefile -scale-to 1920 "$1" "$2" >/dev/null 2>&1 && return 0
	print_err_msg "pdftoppm" "$?"
}

gen_gif_preview() {
	magick "$1"[0] -resize 640x480\> "$2" >/dev/null 2>&1 && return 0
	print_err_msg "magick" "$?"
}

gen_video_preview() {
	ffmpegthumbnailer -i "$1" -o "$2" -s 0 -q 5 >/dev/null 2>&1 && return 0
	print_err_msg "ffmpegthumbnailer" "$?"
}

gen_doc_preview() {
	format="png"
	if libreoffice --headless --convert-to "$format" "$1" \
	--outdir "$CACHE_DIR" >/dev/null 2>&1; then
		f="${1##*/}"
		mv "$CACHE_DIR/${f%.*}.$format" "${2}.$format" && return 0
	fi

	print_err_msg "libreoffice" "$?"
}

gen_djvu_preview() {
	ddjvu -format=tiff -quality=90 -page=1 "$1" "$2" >/dev/null 2>&1 && return 0
	print_err_msg "ddjvu" "$?"
}

gen_audio_preview() {
	ffmpeg -hide_banner -i "$1" "$2" -y >/dev/null 2>&1 && return 0
	print_err_msg "ffmpeg" "$?"
}

gen_font_preview() {
	fontpreview -i "$1" -o "$2" >/dev/null 2>&1 && return 0
	print_err_msg "fontpreview" "$?"
}

gen_postscript_preview() {
	gs -sDEVICE=jpeg -dJPEGQ=100 -dNOPAUSE -dBATCH -dSAFER -r300 \
		-sOutputFile="$2" "$1" >/dev/null 2>&1 && return 0
	print_err_msg "gs (ghostscript)" "$?"
}

gen_svg_preview() {
	magick -background none -size 1920x1080 "$1" "$2" >/dev/null 2>&1 && return 0
	print_err_msg "magick" "$?"
}

gen_img_convert_preview() {
	magick -- "$1" "$2" >/dev/null 2>&1 && return 0
	print_err_msg "magick" "$?"
}

#gen_comic_preview() {
#	comicthumb "$file" "$PCACHE" 1024 >/dev/null 2>&1 && return 0
#	print_err_msg "comicthumb" "$?"
#}

main() {
	case "$type" in
		"image")
			case "$file" in
			*.bmp|*.BMP|*.ico|*.ICO|*.pcx|*.PCX|*.tga|*.TGA)
				hash_file "$file"
				if [ -f "${PCACHE}.jpg" ] || gen_img_convert_preview "$file" "${PCACHE}.jpg" >/dev/null 2>&1; then
					display "${PCACHE}.jpg"
				fi
			;;
			*)
				display "$file"
			;;
			esac
		;;
		"gif")
			hash_file "$file"
			if [ -f "${PCACHE}.jpg" ] || gen_gif_preview "$file" "${PCACHE}.jpg"; then
				display "${PCACHE}.jpg"
			fi
		;;
		"video")
			hash_file "$file"
			if [ -f "${PCACHE}.jpg" ] || gen_video_preview "$file" "${PCACHE}.jpg"; then
				display "${PCACHE}.jpg"
			fi
		;;
		"epub")
			hash_file "$file"
			if [ -f "${PCACHE}.jpg" ] || gen_epub_preview "$file" "${PCACHE}.jpg"; then
				display "${PCACHE}.jpg"
			fi
		;;
		"mobi")
			hash_file "$file"
			if [ -f "${PCACHE}.jpg" ] || gen_mobi_preview "$file" "${PCACHE}.jpg"; then
				display "${PCACHE}.jpg"
			fi
		;;
		"pdf")
			hash_file "$file"
			if [ -f "${PCACHE}.jpg" ] || gen_pdf_preview "$file" "$PCACHE"; then
				display "${PCACHE}.jpg"
			fi
		;;
		"djvu")
			hash_file "$file"
			if [ -f "${PCACHE}.jpg" ] || gen_djvu_preview "$file" "${PCACHE}.jpg"; then
				display "${PCACHE}.jpg"
			fi
		;;
		"audio")
			hash_file "$file"
			if [ -f "${PCACHE}.jpg" ] || gen_audio_preview "$file" "${PCACHE}.jpg"; then
				display "${PCACHE}.jpg"
			fi
		;;
		"font")
			hash_file "$file"
			if [ -f "${PCACHE}.jpg" ] || gen_font_preview "$file" "${PCACHE}.jpg"; then
				display "${PCACHE}.jpg"
			fi
		;;
		"doc")
			hash_file "$file"
			if [ -f "${PCACHE}.png" ] || gen_doc_preview "$file" "$PCACHE"; then
				display "${PCACHE}.png"
			fi
		;;
		"postscript")
			hash_file "$file"
			if [ -f "${PCACHE}.jpg" ] || gen_postscript_preview "$file" "${PCACHE}.jpg"; then
				display "${PCACHE}.jpg"
			fi
		;;
		"svg")
			hash_file "$file"
			if [ -f "${PCACHE}.png" ] || gen_svg_preview "$file" "${PCACHE}.png"; then
				display "${PCACHE}.png"
			fi
		;;
#		"comic")
#			hash_file "$file"
#			if [ -f "${PCACHE}.png" ] || gen_comic_preview "$file" "$PCACHE"; then
#				display "${PCACHE}.png"
#			fi
#		;;
        *)
    esac
}

main "$@"
